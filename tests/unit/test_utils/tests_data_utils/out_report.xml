<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="9" failures="20" skipped="0" tests="35" time="14.376" timestamp="2023-04-05T13:58:30.155770" hostname="MacBook-Pro-Albert.local"><testcase classname="tests.unit.test_utils.tests_data_utils.test_dataset_prep.TestPrepareDataset" name="test_prepare_dataset" time="0.221" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_band_composer.TestBaseBandComposer" name="test_map_band_idx2str" time="0.002" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_band_composer.TestBaseBandComposer" name="test_map_band_name2idx" time="0.001" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_band_composer.TestBaseBandComposer" name="test_get_band_files" time="0.071"><error message="failed on setup with &quot;TypeError: Integer width and height are required.&quot;">&gt;   ???
E   TypeError: int() argument must be a string, a bytes-like object or a number, not 'NoneType'

rasterio/_io.pyx:1378: TypeError

During handling of the above exception, another exception occurred:

tmp_path = Path('/private/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/pytest-of-alberthazipov/pytest-1/test_get_band_files0')

    @pytest.fixture
    def sample_band_files(tmp_path):
        """Creates sample band files in a temporary directory."""
        channels = ["RED", "GRN", "BLU"]
        for ch in channels:
            file_path = tmp_path / f"band_{ch.lower()}.tif"
&gt;           with rasterio.open(file_path, "w") as f:

test_preprocessing/test_band_composer.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/lib/python3.9/site-packages/rasterio/env.py:444: in wrapper
    return f(*args, **kwds)
/opt/anaconda3/lib/python3.9/site-packages/rasterio/__init__.py:314: in open
    dataset = writer(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   TypeError: Integer width and height are required.

rasterio/_io.pyx:1381: TypeError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_band_composer.TestBaseBandComposer" name="test_compose_bands" time="0.002"><error message="failed on setup with &quot;TypeError: Integer width and height are required.&quot;">&gt;   ???
E   TypeError: int() argument must be a string, a bytes-like object or a number, not 'NoneType'

rasterio/_io.pyx:1378: TypeError

During handling of the above exception, another exception occurred:

tmp_path = Path('/private/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/pytest-of-alberthazipov/pytest-1/test_compose_bands0')

    @pytest.fixture
    def sample_band_files(tmp_path):
        """Creates sample band files in a temporary directory."""
        channels = ["RED", "GRN", "BLU"]
        for ch in channels:
            file_path = tmp_path / f"band_{ch.lower()}.tif"
&gt;           with rasterio.open(file_path, "w") as f:

test_preprocessing/test_band_composer.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/lib/python3.9/site-packages/rasterio/env.py:444: in wrapper
    return f(*args, **kwds)
/opt/anaconda3/lib/python3.9/site-packages/rasterio/__init__.py:314: in open
    dataset = writer(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   TypeError: Integer width and height are required.

rasterio/_io.pyx:1381: TypeError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_band_composer.TestBandComposer" name="test_compose_bands" time="0.002"><error message="failed on setup with &quot;TypeError: Integer width and height are required.&quot;">&gt;   ???
E   TypeError: int() argument must be a string, a bytes-like object or a number, not 'NoneType'

rasterio/_io.pyx:1378: TypeError

During handling of the above exception, another exception occurred:

tmp_path = Path('/private/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/pytest-of-alberthazipov/pytest-1/test_compose_bands1')

    @pytest.fixture
    def sample_band_files(tmp_path):
        """Creates sample band files in a temporary directory."""
        channels = ["RED", "GRN", "BLU"]
        for ch in channels:
            file_path = tmp_path / f"band_{ch.lower()}.tif"
&gt;           with rasterio.open(file_path, "w") as f:

test_preprocessing/test_band_composer.py:17: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
/opt/anaconda3/lib/python3.9/site-packages/rasterio/env.py:444: in wrapper
    return f(*args, **kwds)
/opt/anaconda3/lib/python3.9/site-packages/rasterio/__init__.py:314: in open
    dataset = writer(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   TypeError: Integer width and height are required.

rasterio/_io.pyx:1381: TypeError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_crop_raster.TestCropRaster" name="test_crop_raster" time="0.082"><failure message="AssertionError: assert {'driver': 'G...eave': 'band'} == {'driver': 'G...eave': 'band'}&#10;  Use -v to get more diff">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_crop_raster.TestCropRaster object at 0x7fae80bd2700&gt;
sample_raster = '/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/tmpcuibwm_e.tif'

    def test_crop_raster(self, sample_raster):
        # Crop the sample raster and test the output
        with rasterio.open(sample_raster) as src:
            expected_data = src.read(window=Window(10, 10, 50, 50))
            expected_profile = src.profile.copy()
            expected_profile.update({"height": 50, "width": 50, "transform": src.window_transform(Window(10, 10, 50, 50))})
    
        with tempfile.NamedTemporaryFile(suffix=".tif", delete=False) as f:
            crop_raster(sample_raster, Path(f.name), height=50, width=50)
            with rasterio.open(f.name) as src:
                np.testing.assert_array_equal(src.read(), expected_data)
&gt;               assert src.profile == expected_profile
E               AssertionError: assert {'driver': 'G...eave': 'band'} == {'driver': 'G...eave': 'band'}
E                 Use -v to get more diff

test_preprocessing/test_crop_raster.py:34: AssertionError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_dicom_handler.TestDicomConversion" name="test_img_to_dicom" time="0.002"><error message="failed on setup with &quot;FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png'&quot;">test_data_dir = '/Users/albertkhazipov/innofw/path_to_test_data_dir'

    @pytest.fixture(scope="module")
    def test_image(test_data_dir):
        # Load test image from file and return as numpy array
        image_path = os.path.join(test_data_dir, "test_image.png")
&gt;       image = Image.open(image_path)

test_preprocessing/test_dicom_handler.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png', mode = 'r', formats = ['PNG']

    def open(fp, mode="r", formats=None):
        """
        Opens and identifies the given image file.
    
        This is a lazy operation; this function identifies the file, but
        the file remains open and the actual image data is not read from
        the file until you try to process the data (or call the
        :py:meth:`~PIL.Image.Image.load` method).  See
        :py:func:`~PIL.Image.new`. See :ref:`file-handling`.
    
        :param fp: A filename (string), pathlib.Path object or a file object.
           The file object must implement ``file.read``,
           ``file.seek``, and ``file.tell`` methods,
           and be opened in binary mode.
        :param mode: The mode.  If given, this argument must be "r".
        :param formats: A list or tuple of formats to attempt to load the file in.
           This can be used to restrict the set of formats checked.
           Pass ``None`` to try all supported formats. You can print the set of
           available formats by running ``python3 -m PIL`` or using
           the :py:func:`PIL.features.pilinfo` function.
        :returns: An :py:class:`~PIL.Image.Image` object.
        :exception FileNotFoundError: If the file cannot be found.
        :exception PIL.UnidentifiedImageError: If the image cannot be opened and
           identified.
        :exception ValueError: If the ``mode`` is not "r", or if a ``StringIO``
           instance is used for ``fp``.
        :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.
        """
    
        if mode != "r":
            raise ValueError(f"bad mode {repr(mode)}")
        elif isinstance(fp, io.StringIO):
            raise ValueError(
                "StringIO cannot be used to open an image. "
                "Binary data must be used instead."
            )
    
        if formats is None:
            formats = ID
        elif not isinstance(formats, (list, tuple)):
            raise TypeError("formats must be a list or tuple")
    
        exclusive_fp = False
        filename = ""
        if isinstance(fp, Path):
            filename = str(fp.resolve())
        elif is_path(fp):
            filename = fp
    
        if filename:
&gt;           fp = builtins.open(filename, "rb")
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png'

/opt/anaconda3/lib/python3.9/site-packages/PIL/Image.py:3131: FileNotFoundError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_dicom_handler.TestDicomConversion" name="test_dicom_to_img" time="0.001"><error message="failed on setup with &quot;FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm'&quot;">test_data_dir = '/Users/albertkhazipov/innofw/path_to_test_data_dir'

    @pytest.fixture(scope="module")
    def test_dicom(test_data_dir):
        # Load test dicom from file and return as pydicom Dataset
        dicom_path = os.path.join(test_data_dir, "test_dicom.dcm")
&gt;       return dcmread(dicom_path)

test_preprocessing/test_dicom_handler.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm', defer_size = None, stop_before_pixels = False, force = False, specific_tags = None

    def dcmread(
        fp: Union[PathType, BinaryIO, DicomFileLike],
        defer_size: Optional[Union[str, int, float]] = None,
        stop_before_pixels: bool = False,
        force: bool = False,
        specific_tags: Optional[TagListType] = None
    ) -&gt; Union[FileDataset, DicomDir]:
        """Read and parse a DICOM dataset stored in the DICOM File Format.
    
        Read a DICOM dataset stored in accordance with the :dcm:`DICOM File
        Format &lt;part10/chapter_7.html&gt;`. If the dataset is not stored in
        accordance with the File Format (i.e. the preamble and prefix are missing,
        there are missing required Type 1 *File Meta Information Group* elements
        or the entire *File Meta Information* is missing) then you will have to
        set `force` to ``True``.
    
        .. deprecated:: 2.2
    
            Returning a :class:`~pydicom.dicomdir.DicomDir` is deprecated and
            will be removed in v3.0. Use :class:`~pydicom.fileset.FileSet` instead.
    
    
        Examples
        --------
        Read and return a dataset stored in accordance with the DICOM File Format:
    
        &gt;&gt;&gt; ds = pydicom.dcmread("CT_small.dcm")
        &gt;&gt;&gt; ds.PatientName
    
        Read and return a dataset not in accordance with the DICOM File Format:
    
        &gt;&gt;&gt; ds = pydicom.dcmread("rtplan.dcm", force=True)
        &gt;&gt;&gt; ds.PatientName
    
        Use within a context manager:
    
        &gt;&gt;&gt; with pydicom.dcmread("rtplan.dcm") as ds:
        ...     ds.PatientName
    
        Parameters
        ----------
        fp : str or PathLike or file-like
            Either a file-like object, a string containing the file name or the
            path to the file. The file-like object must have ``seek()``,
            ``read()`` and ``tell()`` methods and the caller is responsible for
            closing it (if required).
        defer_size : int, str or float, optional
            If not used then all elements are read into memory. If specified,
            then if a data element's stored value is larger than `defer_size`, the
            value is not read into memory until it is accessed in code. Should be
            the number of bytes to be read as :class:`int` or as a :class:`str`
            with units, e.g. ``'512 KB'``, ``'2 MB'``.
        stop_before_pixels : bool, optional
            If ``False`` (default), the full file will be read and parsed. Set
            ``True`` to stop before reading (7FE0,0010) *Pixel Data* (and all
            subsequent elements).
        force : bool, optional
            If ``False`` (default), raises an
            :class:`~pydicom.errors.InvalidDicomError` if the file is
            missing the *File Meta Information* header. Set to ``True`` to force
            reading even if no *File Meta Information* header is found.
        specific_tags : list of (int or str or 2-tuple of int), optional
            If used the only the supplied tags will be returned. The supplied
            elements can be tags or keywords. Note that the element (0008,0005)
            *Specific Character Set* is always returned if present - this ensures
            correct decoding of returned text values.
    
        Returns
        -------
        FileDataset or DicomDir
            An instance of :class:`~pydicom.dataset.FileDataset` that represents
            a parsed DICOM file, unless the dataset is a *Media Storage Directory*
            instance in which case it will be a
            :class:`~pydicom.dicomdir.DicomDir`.
    
        Raises
        ------
        InvalidDicomError
            If `force` is ``False`` and the file is not a valid DICOM file.
        TypeError
            If `fp` is ``None`` or of an unsupported type.
    
        See Also
        --------
        pydicom.dataset.FileDataset
            Data class that is returned.
        pydicom.filereader.read_partial
            Only read part of a DICOM file, stopping on given conditions.
        """
        # Open file if not already a file object
        caller_owns_file = True
        fp = path_from_pathlike(fp)
        if isinstance(fp, str):
            # caller provided a file name; we own the file handle
            caller_owns_file = False
            logger.debug("Reading file '{0}'".format(fp))
&gt;           fp = open(fp, 'rb')
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm'

/opt/anaconda3/lib/python3.9/site-packages/pydicom/filereader.py:993: FileNotFoundError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_dicom_handler.TestDicomConversion" name="test_raster_to_dicom" time="0.001"><error message="failed on setup with &quot;FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png'&quot;">test_data_dir = '/Users/albertkhazipov/innofw/path_to_test_data_dir'

    @pytest.fixture(scope="module")
    def test_image(test_data_dir):
        # Load test image from file and return as numpy array
        image_path = os.path.join(test_data_dir, "test_image.png")
&gt;       image = Image.open(image_path)

test_preprocessing/test_dicom_handler.py:18: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png', mode = 'r', formats = ['PNG']

    def open(fp, mode="r", formats=None):
        """
        Opens and identifies the given image file.
    
        This is a lazy operation; this function identifies the file, but
        the file remains open and the actual image data is not read from
        the file until you try to process the data (or call the
        :py:meth:`~PIL.Image.Image.load` method).  See
        :py:func:`~PIL.Image.new`. See :ref:`file-handling`.
    
        :param fp: A filename (string), pathlib.Path object or a file object.
           The file object must implement ``file.read``,
           ``file.seek``, and ``file.tell`` methods,
           and be opened in binary mode.
        :param mode: The mode.  If given, this argument must be "r".
        :param formats: A list or tuple of formats to attempt to load the file in.
           This can be used to restrict the set of formats checked.
           Pass ``None`` to try all supported formats. You can print the set of
           available formats by running ``python3 -m PIL`` or using
           the :py:func:`PIL.features.pilinfo` function.
        :returns: An :py:class:`~PIL.Image.Image` object.
        :exception FileNotFoundError: If the file cannot be found.
        :exception PIL.UnidentifiedImageError: If the image cannot be opened and
           identified.
        :exception ValueError: If the ``mode`` is not "r", or if a ``StringIO``
           instance is used for ``fp``.
        :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.
        """
    
        if mode != "r":
            raise ValueError(f"bad mode {repr(mode)}")
        elif isinstance(fp, io.StringIO):
            raise ValueError(
                "StringIO cannot be used to open an image. "
                "Binary data must be used instead."
            )
    
        if formats is None:
            formats = ID
        elif not isinstance(formats, (list, tuple)):
            raise TypeError("formats must be a list or tuple")
    
        exclusive_fp = False
        filename = ""
        if isinstance(fp, Path):
            filename = str(fp.resolve())
        elif is_path(fp):
            filename = fp
    
        if filename:
&gt;           fp = builtins.open(filename, "rb")
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_image.png'

/opt/anaconda3/lib/python3.9/site-packages/PIL/Image.py:3131: FileNotFoundError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_dicom_handler.TestDicomConversion" name="test_add_image" time="0.001"><error message="failed on setup with &quot;FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm'&quot;">test_data_dir = '/Users/albertkhazipov/innofw/path_to_test_data_dir'

    @pytest.fixture(scope="module")
    def test_dicom(test_data_dir):
        # Load test dicom from file and return as pydicom Dataset
        dicom_path = os.path.join(test_data_dir, "test_dicom.dcm")
&gt;       return dcmread(dicom_path)

test_preprocessing/test_dicom_handler.py:26: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

fp = '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm', defer_size = None, stop_before_pixels = False, force = False, specific_tags = None

    def dcmread(
        fp: Union[PathType, BinaryIO, DicomFileLike],
        defer_size: Optional[Union[str, int, float]] = None,
        stop_before_pixels: bool = False,
        force: bool = False,
        specific_tags: Optional[TagListType] = None
    ) -&gt; Union[FileDataset, DicomDir]:
        """Read and parse a DICOM dataset stored in the DICOM File Format.
    
        Read a DICOM dataset stored in accordance with the :dcm:`DICOM File
        Format &lt;part10/chapter_7.html&gt;`. If the dataset is not stored in
        accordance with the File Format (i.e. the preamble and prefix are missing,
        there are missing required Type 1 *File Meta Information Group* elements
        or the entire *File Meta Information* is missing) then you will have to
        set `force` to ``True``.
    
        .. deprecated:: 2.2
    
            Returning a :class:`~pydicom.dicomdir.DicomDir` is deprecated and
            will be removed in v3.0. Use :class:`~pydicom.fileset.FileSet` instead.
    
    
        Examples
        --------
        Read and return a dataset stored in accordance with the DICOM File Format:
    
        &gt;&gt;&gt; ds = pydicom.dcmread("CT_small.dcm")
        &gt;&gt;&gt; ds.PatientName
    
        Read and return a dataset not in accordance with the DICOM File Format:
    
        &gt;&gt;&gt; ds = pydicom.dcmread("rtplan.dcm", force=True)
        &gt;&gt;&gt; ds.PatientName
    
        Use within a context manager:
    
        &gt;&gt;&gt; with pydicom.dcmread("rtplan.dcm") as ds:
        ...     ds.PatientName
    
        Parameters
        ----------
        fp : str or PathLike or file-like
            Either a file-like object, a string containing the file name or the
            path to the file. The file-like object must have ``seek()``,
            ``read()`` and ``tell()`` methods and the caller is responsible for
            closing it (if required).
        defer_size : int, str or float, optional
            If not used then all elements are read into memory. If specified,
            then if a data element's stored value is larger than `defer_size`, the
            value is not read into memory until it is accessed in code. Should be
            the number of bytes to be read as :class:`int` or as a :class:`str`
            with units, e.g. ``'512 KB'``, ``'2 MB'``.
        stop_before_pixels : bool, optional
            If ``False`` (default), the full file will be read and parsed. Set
            ``True`` to stop before reading (7FE0,0010) *Pixel Data* (and all
            subsequent elements).
        force : bool, optional
            If ``False`` (default), raises an
            :class:`~pydicom.errors.InvalidDicomError` if the file is
            missing the *File Meta Information* header. Set to ``True`` to force
            reading even if no *File Meta Information* header is found.
        specific_tags : list of (int or str or 2-tuple of int), optional
            If used the only the supplied tags will be returned. The supplied
            elements can be tags or keywords. Note that the element (0008,0005)
            *Specific Character Set* is always returned if present - this ensures
            correct decoding of returned text values.
    
        Returns
        -------
        FileDataset or DicomDir
            An instance of :class:`~pydicom.dataset.FileDataset` that represents
            a parsed DICOM file, unless the dataset is a *Media Storage Directory*
            instance in which case it will be a
            :class:`~pydicom.dicomdir.DicomDir`.
    
        Raises
        ------
        InvalidDicomError
            If `force` is ``False`` and the file is not a valid DICOM file.
        TypeError
            If `fp` is ``None`` or of an unsupported type.
    
        See Also
        --------
        pydicom.dataset.FileDataset
            Data class that is returned.
        pydicom.filereader.read_partial
            Only read part of a DICOM file, stopping on given conditions.
        """
        # Open file if not already a file object
        caller_owns_file = True
        fp = path_from_pathlike(fp)
        if isinstance(fp, str):
            # caller provided a file name; we own the file handle
            caller_owns_file = False
            logger.debug("Reading file '{0}'".format(fp))
&gt;           fp = open(fp, 'rb')
E           FileNotFoundError: [Errno 2] No such file or directory: '/Users/albertkhazipov/innofw/path_to_test_data_dir/test_dicom.dcm'

/opt/anaconda3/lib/python3.9/site-packages/pydicom/filereader.py:993: FileNotFoundError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts" name="test_clean_salts_with_valid_smiles" time="0.021"><failure message="AssertionError: assert &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816701c0&gt; == &lt;rdkit.Chem.rdchem.Mol object at 0x7fae81645a00&gt;&#10; +  where &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816701c0&gt; = clean_salts('CC(=O)O.[Na+]')">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts object at 0x7fae81248430&gt;

    def test_clean_salts_with_valid_smiles(self):
        smiles = "CC(=O)O.[Na+]"
        expected_result = Chem.MolFromSmiles("CC(=O)O")
&gt;       assert clean_salts(smiles) == expected_result
E       AssertionError: assert &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816701c0&gt; == &lt;rdkit.Chem.rdchem.Mol object at 0x7fae81645a00&gt;
E        +  where &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816701c0&gt; = clean_salts('CC(=O)O.[Na+]')

test_preprocessing/test_qsar_tools.py:12: AssertionError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts" name="test_clean_salts_with_invalid_smiles" time="0.002" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts" name="test_clean_salts_with_empty_smiles" time="0.002"><failure message="AssertionError: assert &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816703a0&gt; is None&#10; +  where &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816703a0&gt; = clean_salts('')">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts object at 0x7fae81237ac0&gt;

    def test_clean_salts_with_empty_smiles(self):
        smiles = ""
&gt;       assert clean_salts(smiles) is None
E       AssertionError: assert &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816703a0&gt; is None
E        +  where &lt;rdkit.Chem.rdchem.Mol object at 0x7fae816703a0&gt; = clean_salts('')

test_preprocessing/test_qsar_tools.py:20: AssertionError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts" name="test_clean_salts_with_none_input" time="0.006"><failure message="TypeError: No registered converter was able to produce a C++ rvalue of type std::__1::basic_string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;, std::__1::allocator&lt;wchar_t&gt; &gt; from this Python object of type NoneType">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_qsar_tools.TestCleanSalts object at 0x7fae812486a0&gt;

    def test_clean_salts_with_none_input(self):
&gt;       assert clean_salts(None) is None

test_preprocessing/test_qsar_tools.py:23: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

smiles = None

    def clean_salts(smiles: str) -&gt; Optional[Chem.rdchem.Mol]:
        remover = SaltRemover(defnFormat="smarts")
&gt;       mol = Chem.MolFromSmiles(smiles)
E       TypeError: No registered converter was able to produce a C++ rvalue of type std::__1::basic_string&lt;wchar_t, std::__1::char_traits&lt;wchar_t&gt;, std::__1::allocator&lt;wchar_t&gt; &gt; from this Python object of type NoneType

../../../../innofw/utils/data_utils/preprocessing/qsar_tools.py:9: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_raster_handler.TestRasterDataset" name="test_create_dataset" time="0.007" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_raster_handler.TestRasterDataset" name="test_add_band" time="0.006"><failure message="rasterio.errors.UnsupportedOperation: not readable">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_raster_handler.TestRasterDataset object at 0x7fae81248f40&gt;
temp_file = Path('/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/tmp6ej7ouab.tif')
metadata = {'count': 1, 'crs': CRS.from_epsg(4326), 'driver': 'GTiff', 'dtype': 'uint8', ...}

    def test_add_band(self, temp_file, metadata):
        dataset = RasterDataset(temp_file, metadata)
    
        # create a test band
        with rio.open(temp_file, "w", **metadata) as f:
&gt;           f.write(f.read(1) + 1, 2)

test_preprocessing/test_raster_handler.py:39: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

&gt;   ???
E   rasterio.errors.UnsupportedOperation: not readable

rasterio/_io.pyx:472: UnsupportedOperation</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestBaseSatelliteSource" name="test_find_metadata_file" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BaseSatelliteSource with abstract methods find_metadata_file, parse_metadata_file&quot;">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestBaseSatelliteSource object at 0x7fae8124fb80&gt;

    @pytest.fixture
    def base_satellite_source(self):
&gt;       return BaseSatelliteSource()
E       TypeError: Can't instantiate abstract class BaseSatelliteSource with abstract methods find_metadata_file, parse_metadata_file

test_preprocessing/test_satellite_sources.py:12: TypeError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestBaseSatelliteSource" name="test_parse_metadata_file" time="0.001"><error message="failed on setup with &quot;TypeError: Can't instantiate abstract class BaseSatelliteSource with abstract methods find_metadata_file, parse_metadata_file&quot;">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestBaseSatelliteSource object at 0x7fae8124fd00&gt;

    @pytest.fixture
    def base_satellite_source(self):
&gt;       return BaseSatelliteSource()
E       TypeError: Can't instantiate abstract class BaseSatelliteSource with abstract methods find_metadata_file, parse_metadata_file

test_preprocessing/test_satellite_sources.py:12: TypeError</error></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestSentinel2" name="test_find_metadata_file" time="0.001"><failure message="AttributeError: 'str' object has no attribute 'rglob'">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestSentinel2 object at 0x7fae8124ff70&gt;
sentinel2 = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Sentinel2 object at 0x7fae8154ca30&gt;

    def test_find_metadata_file(self, sentinel2):
        with pytest.raises(ValueError):
&gt;           sentinel2.find_metadata_file()

test_preprocessing/test_satellite_sources.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Sentinel2 object at 0x7fae8154ca30&gt;

    def find_metadata_file(self) -&gt; Path:
&gt;       files = list(self.src_folder.rglob("MTD_MSIL1C.xml"))
E       AttributeError: 'str' object has no attribute 'rglob'

../../../../innofw/utils/data_utils/preprocessing/satellite_sources.py:59: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestSentinel2" name="test_parse_metadata_file" time="0.004"><failure message="AssertionError">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestSentinel2 object at 0x7fae8125c100&gt;
sentinel2 = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Sentinel2 object at 0x7fae8154b880&gt;

    def test_parse_metadata_file(self, sentinel2):
        sentinel2.src_folder = Path('.')
        sentinel2._get_bands_from_tree = MagicMock()
        sentinel2._construct_band_mapping = MagicMock()
        sentinel2._get_date_acquired_from_tree = MagicMock()
    
        with patch('xml.etree.ElementTree.parse') as parse_mock:
            parse_mock.return_value = MagicMock()
&gt;           assert sentinel2.parse_metadata_file(Path('')) == {
                'bands': sentinel2._get_bands_from_tree.return_value,
                'mapping': sentinel2._construct_band_mapping.return_value,
                'num_bands': len(sentinel2._get_bands_from_tree.return_value),
                'date_acquired': sentinel2._get_date_acquired_from_tree.return_value,
            }

test_preprocessing/test_satellite_sources.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Sentinel2 object at 0x7fae8154b880&gt;, metadata_file = Path('.')

    def parse_metadata_file(self, metadata_file: FilePath) -&gt; dict:
        tree = ElementTree.parse(metadata_file)
        bands = self._get_bands_from_tree(tree)
&gt;       assert len(bands) &gt; 0
E       AssertionError

../../../../innofw/utils/data_utils/preprocessing/satellite_sources.py:70: AssertionError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestLandsat8" name="test_find_metadata_file" time="0.001"><failure message="AttributeError: 'str' object has no attribute 'rglob'">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestLandsat8 object at 0x7fae8125c370&gt;
landsat8 = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Landsat8 object at 0x7fae8175bf10&gt;

    def test_find_metadata_file(self, landsat8):
        with pytest.raises(ValueError):
&gt;           landsat8.find_metadata_file()

test_preprocessing/test_satellite_sources.py:64: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Landsat8 object at 0x7fae8175bf10&gt;

    def find_metadata_file(self) -&gt; Path:
&gt;       files = list(self.src_folder.rglob("*MTL.TXT")) + list(
            self.src_folder.rglob("*MTL.txt")
        )
E       AttributeError: 'str' object has no attribute 'rglob'

../../../../innofw/utils/data_utils/preprocessing/satellite_sources.py:131: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestLandsat8" name="test_parse_metadata_file" time="0.002"><failure message="AssertionError">self = &lt;tests.unit.test_utils.tests_data_utils.test_preprocessing.test_satellite_sources.TestLandsat8 object at 0x7fae8125c4c0&gt;
landsat8 = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Landsat8 object at 0x7fae817857c0&gt;

    def test_parse_metadata_file(self, landsat8):
        with TemporaryDirectory() as tmp:
            metadata_path = Path(tmp) / 'LC08_L1TP_200027_20190702_20190709_01_T1_MTL.txt'
            metadata_path.touch()
    
            landsat8.src_folder = Path(tmp)
    
&gt;           assert landsat8.parse_metadata_file(metadata_path) == {
                'bands': {},
                'mapping': {},
                'num_bands': 0,
                'date_acquired': '1970-01-01',
            }

test_preprocessing/test_satellite_sources.py:80: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.preprocessing.satellite_sources.Landsat8 object at 0x7fae817857c0&gt;
metadata_file = Path('/var/folders/c0/83yx0xpx6y39p9rt9s83rg5r0000gn/T/tmp58aqtcsu/LC08_L1TP_200027_20190702_20190709_01_T1_MTL.txt')

    def parse_metadata_file(self, metadata_file: FilePath) -&gt; dict:
        bands: Dict[int, str] = dict()
        band_mapping: Dict[str, int] = dict()
        mul_factors: Dict[int, float] = dict()
        add_factors: Dict[int, float] = dict()
        sun_elevation = 0.0
        date_acquired = "1970-01-01"
    
        with open(metadata_file) as file:
            for line in file:
                try:
                    key, value = line.strip().split(" = ")
                except ValueError:
                    continue
    
                if (
                    key.startswith("FILE_NAME_BAND_")
                    and key != "FILE_NAME_BAND_QUALITY"
                ):
                    band_index = self._band_index_from_key(key)
                    bands[band_index] = self._remove_quotes(value)
                    band_tag = self._band_tag_from_index(band_index)
                    band_mapping[band_tag] = band_index
                elif key.startswith("REFLECTANCE_MULT_BAND_"):
                    band_index = self._band_index_from_key(key)
                    mul_factors[band_index] = float(value)
                elif key.startswith("REFLECTANCE_ADD_BAND_"):
                    band_index = self._band_index_from_key(key)
                    add_factors[band_index] = float(value)
                elif key == "SUN_ELEVATION":
                    sun_elevation = radians(float(value))
                elif key == "DATE_ACQUIRED":
                    date_acquired = value
    
&gt;       assert len(bands) &gt; 0
E       AssertionError

../../../../innofw/utils/data_utils/preprocessing/satellite_sources.py:175: AssertionError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_norming" time="0.005"><failure message="TypeError: unsupported operand type(s) for -: 'NoneType' and 'NoneType'">img = None

    def test_norming(img):
&gt;       normalized = norming(img)

test_transforms/test_db_scan.py:14: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None

    def norming(img):
        mx, mn = npmax(img), npmin(img)
&gt;       if mx - mn == 0:
E       TypeError: unsupported operand type(s) for -: 'NoneType' and 'NoneType'

../../../../innofw/utils/data_utils/transforms/db_scan.py:12: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_make_hist" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'shape'">img = None

    def test_make_hist(img):
&gt;       hist = make_hist(img)

test_transforms/test_db_scan.py:20: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None, how = 'all', thresh1 = 10, thresh2 = -20

    def make_hist(img, how="all", thresh1=10, thresh2=-20):
        temp = defaultdict(int)
&gt;       for i in range(img.shape[0]):
E       AttributeError: 'NoneType' object has no attribute 'shape'

../../../../innofw/utils/data_utils/transforms/db_scan.py:19: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_make_kernel_trick" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'shape'">img = None

    def test_make_kernel_trick(img):
&gt;       kernel = make_kernel_trick(img)

test_transforms/test_db_scan.py:25: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None, how = 'all'

    def make_kernel_trick(img, how="all"):
        answer = []
&gt;       for i in range(img.shape[0]):
E       AttributeError: 'NoneType' object has no attribute 'shape'

../../../../innofw/utils/data_utils/transforms/db_scan.py:33: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_dekernel" time="0.001"><failure message="IndexError: tuple index out of range">zipped = [((1, 2), 5), ((2, 3), 7)], shape = (3, 4)

    def dekernel(zipped, shape=(512, 512)):
        img = zeros(shape)
        for x, y in zipped:
            try:
&gt;               img[x[1], x[2]] = y
E               IndexError: tuple index out of range

../../../../innofw/utils/data_utils/transforms/db_scan.py:44: IndexError

During handling of the above exception, another exception occurred:

    def test_dekernel():
        zipped = [((1, 2), 5), ((2, 3), 7)]
&gt;       img = dekernel(zipped, shape=(3, 4))

test_transforms/test_db_scan.py:31: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

zipped = [((1, 2), 5), ((2, 3), 7)], shape = (3, 4)

    def dekernel(zipped, shape=(512, 512)):
        img = zeros(shape)
        for x, y in zipped:
            try:
                img[x[1], x[2]] = y
            except:
                if (x[1] &lt; 0) or (x[1] &gt; shape[0]):
                    print("x[1] is out of bounds [0,", shape[0], "]")
&gt;               if (x[2] &lt; 0) or (x[2] &gt; shape[1]):
E               IndexError: tuple index out of range

../../../../innofw/utils/data_utils/transforms/db_scan.py:48: IndexError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_make_mask" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'shape'">img = None

    def test_make_mask(img):
&gt;       mask = make_mask(img)

test_transforms/test_db_scan.py:36: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None, cluster = 0

    def make_mask(img, cluster=0):
&gt;       newimg = zeros(img.shape)
E       AttributeError: 'NoneType' object has no attribute 'shape'

../../../../innofw/utils/data_utils/transforms/db_scan.py:54: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan" name="test_make_contrasted" time="0.001"><failure message="TypeError: unsupported operand type(s) for -: 'NoneType' and 'int'">img = None

    def test_make_contrasted(img):
&gt;       contrasted = make_contrasted(img)

test_transforms/test_db_scan.py:41: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None, contrast = 20

    def make_contrasted(img, contrast=20):
        # these values have been found experimentally and work for brain CT images.
        newimg = img
        f = 131 * (contrast + 127) / (127 * (131 - contrast))
&gt;       newimg = f * (newimg - 127) + 127
E       TypeError: unsupported operand type(s) for -: 'NoneType' and 'int'

../../../../innofw/utils/data_utils/transforms/db_scan.py:68: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan.TestMakeContrasted" name="test_call" time="0.001"><failure message="AttributeError: 'NoneType' object has no attribute 'shape'">self = &lt;tests.unit.test_utils.tests_data_utils.test_transforms.test_db_scan.TestMakeContrasted object at 0x7fae81365af0&gt;, img = None

    def test_call(self, img):
        contraster = MakeContrasted()
&gt;       output = contraster(img)

test_transforms/test_db_scan.py:48: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
../../../../innofw/utils/data_utils/transforms/db_scan.py:94: in __call__
    kerneled = make_kernel_trick(image)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

img = None, how = 'all'

    def make_kernel_trick(img, how="all"):
        answer = []
&gt;       for i in range(img.shape[0]):
E       AttributeError: 'NoneType' object has no attribute 'shape'

../../../../innofw/utils/data_utils/transforms/db_scan.py:33: AttributeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression" name="test_valid_input" time="0.136"><failure message="TypeError: Expected type 'numpy.ndarray', got NoneType.">self = &lt;tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression object at 0x7fae81373f10&gt;, sample_image = None
suppressed_image = None

    def test_valid_input(self, sample_image, suppressed_image):
        suppress = RibSuppression()
&gt;       result = suppress(sample_image)["image"]

test_transforms/test_rib_suppression.py:24: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.transforms.rib_suppression.RibSuppression object at 0x7fae814a61c0&gt;, image = None, bbox = None, mask = None, keypoints = None
force_apply = False, args = (), kwargs = {}

    def __call__(
        self,
        image,
        bbox=None,
        mask=None,
        keypoints=None,
        force_apply=False,
        *args,
        **kwargs,
    ):
        """
        Perform the ribs suppression in chest X-ray scans.
    
        :param image: an image that will be processed.
        :param bbox: a bounding box in pascal voc format, e.g. [x_min, y_min, x_max, y_max].
        :param mask: a mask for an input image.
        :param keypoints: a list of points in 'xy' format, e.g. [(x, y), ...].
        :return: a suppressed image.
        """
        if not isinstance(image, np.ndarray):
&gt;           raise TypeError(
                "Expected type 'numpy.ndarray', got "
                + type(image).__name__
                + "."
            )
E           TypeError: Expected type 'numpy.ndarray', got NoneType.

../../../../innofw/utils/data_utils/transforms/rib_suppression.py:53: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression" name="test_non_numpy_input" time="0.070" /><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression" name="test_unequal_shape_input" time="0.066"><failure message="TypeError: 'NoneType' object is not subscriptable">self = &lt;tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression object at 0x7fae81365b20&gt;, sample_image = None

    def test_unequal_shape_input(self, sample_image):
        suppress = RibSuppression()
&gt;       input_image = sample_image[:100, :100]
E       TypeError: 'NoneType' object is not subscriptable

test_transforms/test_rib_suppression.py:34: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression" name="test_invalid_model_path" time="0.064"><failure message="TypeError: Expected type 'numpy.ndarray', got NoneType.">self = &lt;tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression object at 0x7fae813656a0&gt;, sample_image = None
monkeypatch = &lt;_pytest.monkeypatch.MonkeyPatch object at 0x7fae8180ca60&gt;

    def test_invalid_model_path(self, sample_image, monkeypatch):
        suppress = RibSuppression()
        model_path = Path(__file__).parent.absolute() / "test_data/invalid_model.pt"
        monkeypatch.setattr(suppress, "model_suppression", model_path)
        with pytest.raises(RuntimeError):
&gt;           suppress(sample_image)["image"]

test_transforms/test_rib_suppression.py:43: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.transforms.rib_suppression.RibSuppression object at 0x7fae8180c940&gt;, image = None, bbox = None, mask = None, keypoints = None
force_apply = False, args = (), kwargs = {}

    def __call__(
        self,
        image,
        bbox=None,
        mask=None,
        keypoints=None,
        force_apply=False,
        *args,
        **kwargs,
    ):
        """
        Perform the ribs suppression in chest X-ray scans.
    
        :param image: an image that will be processed.
        :param bbox: a bounding box in pascal voc format, e.g. [x_min, y_min, x_max, y_max].
        :param mask: a mask for an input image.
        :param keypoints: a list of points in 'xy' format, e.g. [(x, y), ...].
        :return: a suppressed image.
        """
        if not isinstance(image, np.ndarray):
&gt;           raise TypeError(
                "Expected type 'numpy.ndarray', got "
                + type(image).__name__
                + "."
            )
E           TypeError: Expected type 'numpy.ndarray', got NoneType.

../../../../innofw/utils/data_utils/transforms/rib_suppression.py:53: TypeError</failure></testcase><testcase classname="tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression" name="test_equalize_output" time="0.063"><failure message="TypeError: Expected type 'numpy.ndarray', got NoneType.">self = &lt;tests.unit.test_utils.tests_data_utils.test_transforms.test_rib_suppression.TestRibSuppression object at 0x7fae81380250&gt;, sample_image = None

    def test_equalize_output(self, sample_image):
        suppress = RibSuppression(equalize_out=True)
&gt;       result = suppress(sample_image)["image"]

test_transforms/test_rib_suppression.py:47: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;innofw.utils.data_utils.transforms.rib_suppression.RibSuppression object at 0x7fae8183d9a0&gt;, image = None, bbox = None, mask = None, keypoints = None
force_apply = False, args = (), kwargs = {}

    def __call__(
        self,
        image,
        bbox=None,
        mask=None,
        keypoints=None,
        force_apply=False,
        *args,
        **kwargs,
    ):
        """
        Perform the ribs suppression in chest X-ray scans.
    
        :param image: an image that will be processed.
        :param bbox: a bounding box in pascal voc format, e.g. [x_min, y_min, x_max, y_max].
        :param mask: a mask for an input image.
        :param keypoints: a list of points in 'xy' format, e.g. [(x, y), ...].
        :return: a suppressed image.
        """
        if not isinstance(image, np.ndarray):
&gt;           raise TypeError(
                "Expected type 'numpy.ndarray', got "
                + type(image).__name__
                + "."
            )
E           TypeError: Expected type 'numpy.ndarray', got NoneType.

../../../../innofw/utils/data_utils/transforms/rib_suppression.py:53: TypeError</failure></testcase></testsuite></testsuites>